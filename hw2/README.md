## Лабораторна робота №2
## Принцип підстановки LSP
## 1. Коротко про LSP
Принцип підстановки Лісков (Liskov Substitution Principle, LSP) стверджує, що об’єкти підкласів мають бути повністю взаємозамінними з об’єктами базового класу без порушення коректності роботи програми.
Іншими словами, код, який працює з базовим класом, не повинен змінювати свою поведінку при підстановці його нащадка.
## 2. Приклади порушення LSP 
### Приклад 1: Car - ElectricCar
#### Опис проблеми
Базовий клас Car має метод refuel() — заправка паливом.
Підклас ElectricCar перевизначає цей метод або викидає помилку, оскільки електромобілі не заправляються бензином.
#### Чому це порушує LSP
Код, який працює з типом Car, очікує, що метод refuel() завжди доступний і працює коректно.
Підстановка ElectricCar порушує цей контракт.
#### Наслідки
Помилки під час виконання
Порушення поліморфізму
Необхідність перевірок типу автомобіля
#### Перепроєктування
Розділити поведінку за допомогою інтерфейсів:

interface Refuelable
interface Rechargeable
class PetrolCar implements Refuelable
class ElectricCar implements Rechargeable

Базовий клас Car не повинен містити поведінку, яка не є універсальною.

### Приклад 2: Vehicle - Bicycle
#### Опис проблеми
Клас Vehicle має метод startEngine().
Підклас Bicycle перевизначає його як порожній або кидає виняток, адже велосипед не має двигуна.
#### Чому це порушує LSP
Метод startEngine() є частиною контракту Vehicle, але Bicycle не може його коректно реалізувати.
#### Наслідки
Логічні помилки
Плутанина в ієрархії
Порушення принципу “is-a”
#### Перепроєктування
Винести двигун у окрему абстракцію:

class Vehicle
interface EnginePowered
class Car extends Vehicle implements EnginePowered
class Bicycle extends Vehicle

Тепер тільки транспорт із двигуном реалізує відповідну поведінку.
### Приклад 3: Country - SanctionedCountry
#### Опис проблеми
Базовий клас Country має метод tradeWith(otherCountry).
Підклас SanctionedCountry забороняє торгівлю та завжди повертає помилку.
#### Чому це порушує LSP
Контракт базового класу передбачає можливість міжнародної торгівлі.
Підклас вводить додаткові обмеження, які ламають очікування клієнтського коду.
#### Наслідки
Некоректна бізнес-логіка
Ускладнення міжнародних сценаріїв
Неочікувані відмови операцій
#### Перепроєктування
Перенести обмеження в окремий рівень політик:

class Country
interface TradePolicy
class FreeTradePolicy
class SanctionsPolicy

Країна використовує політику, а не змінює свою базову поведінку через наслідування.
### Приклад 4: PaymentService - FreePaymentService
#### Опис проблеми
PaymentService має метод pay(amount), який списує кошти.
FreePaymentService ігнорує суму або завжди повертає успіх без реальної оплати.
#### Чому це порушує LSP
Клієнтський код очікує реального списання коштів. Підклас змінює бізнес-логіку, що призводить до некоректної роботи системи.
#### Наслідки
Фінансові помилки
Порушення бізнес-інваріантів
Складність тестування
#### Перепроєктування
Винести спільний контракт на рівень абстракції:

interface PaymentProcessor
class RealPaymentService
class FreeTrialPaymentService

Кожна реалізація має чітко визначену поведінку.
## 3.Висновок
У ході роботи було розглянуто приклади порушення принципу підстановки Лісков на практичних та зрозумілих моделях (транспортні засоби та країни). Ці приклади показали, що неправильне використання наслідування призводить до зміни очікуваної поведінки об’єктів і порушення поліморфізму.
Для дотримання LSP базові класи повинні містити лише спільну та універсальну поведінку, а специфічні можливості мають бути винесені в окремі інтерфейси або реалізовані через композицію. Такий підхід робить код стабільним, зрозумілим і придатним до розширення без виникнення помилок.